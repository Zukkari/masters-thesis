\TODO{
    Describe how we selected the dataset.
    We might be using the dataset that was used by the authors of another paper, so that we
    can compare our results to those that they have already provided.
    Also mention here that some of the projects in our corpus were not using the build system,
    so we were not able to analyze them.
    Here we can say that we excluded them because we could build them, but SonarQube itself
    cannot analyze projects that do not use build systems.
}

To evaluate the plugin and see how it performs, we needed to perform an analysis of existing applications and then
perform statistical analysis to determine if the results are statistically significant.
The analysis itself has two main objectives.
Firstly, we wanted to see how existing (previously implemented by the literature) code smells were distributed
inside analyzed applications.
Secondly, we wanted to see how new code smells (previously not implemented by the literature) are distributed
inside analyzed applications.


For this purpose, we used a corpus consisting of 1509 applications that were published in~\cite{kotlin_android_corpus} by
\citeauthor{kotlin_android_corpus}.
This corpus consists of Java and Kotlin applications for the Android platform.
In our analysis, we analyzed applications developed in Java and ignored ones implemented in Kotlin.

The main reason why we selected this corpus is because it provides links to the original repositories.
This is important, because our tool relies on the analysis of the source code and not compiled \verb|.apk| binaries
that are deployed the the Android platform.
This way we were able to clone the original repositories and perform source code analysis of the applications.
